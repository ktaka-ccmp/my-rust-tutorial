<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Personal tutorial for Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Personal tutorial for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromrequestparts-in-axum-comprehensive-guide"><a class="header" href="#fromrequestparts-in-axum-comprehensive-guide">FromRequestParts in Axum: Comprehensive Guide</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><code>FromRequestParts</code> is a trait in Axum used to extract data from the request parts (headers, URI, method, etc.) without consuming the request body. It's particularly useful for accessing request metadata while preserving the body for other operations.</p>
<h2 id="definition-and-core-concepts"><a class="header" href="#definition-and-core-concepts">Definition and Core Concepts</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FromRequestParts&lt;S&gt;: Sized {
    type Rejection: IntoResponse;

    fn from_request_parts(
        parts: &amp;mut Parts,
        state: &amp;S,
    ) -&gt; impl Future&lt;Output = Result&lt;Self, Self::Rejection&gt;&gt; + Send;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ul>
<li><code>parts</code>: Represents the components of an HTTP request (headers, URI)</li>
<li><code>state</code>: A shared application state passed to the extractor</li>
<li><code>Rejection</code>: The type returned when extraction fails, convertible to an HTTP response</li>
</ul>
<h2 id="when-and-how-extractors-are-called"><a class="header" href="#when-and-how-extractors-are-called">When and How Extractors Are Called</a></h2>
<h3 id="automatic-invocation"><a class="header" href="#automatic-invocation">Automatic Invocation</a></h3>
<p>Extractors in Axum are automatically called when a request is processed. You don't need to explicitly invoke them:</p>
<ol>
<li>Axum calls appropriate extractors for parameters defined in your handler function</li>
<li>Extractors are called in order from left to right in the handler's parameter list</li>
<li>Only one body-consuming extractor is allowed, and it must be the last parameter</li>
</ol>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>The type must be an argument in the handler function for the extractor to be called</li>
<li>The handler's parameter type must implement <code>FromRequestParts</code></li>
</ul>
<h2 id="implementation-examples"><a class="header" href="#implementation-examples">Implementation Examples</a></h2>
<h3 id="example-1-custom-header-extractor"><a class="header" href="#example-1-custom-header-extractor">Example 1: Custom Header Extractor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::FromRequestParts,
    http::{request::Parts, HeaderMap},
    response::IntoResponse,
};
use futures::future::BoxFuture;

struct CustomHeader(String);

#[derive(Debug)]
struct MissingHeader;

impl IntoResponse for MissingHeader {
    fn into_response(self) -&gt; axum::response::Response {
        axum::response::Response::builder()
            .status(400)
            .body("Missing required header".into())
            .unwrap()
    }
}

impl&lt;S&gt; FromRequestParts&lt;S&gt; for CustomHeader {
    type Rejection = MissingHeader;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let headers = parts.headers.clone();
        Box::pin(async move {
            if let Some(header_value) = headers.get("X-Custom-Header") {
                Ok(CustomHeader(header_value.to_str().unwrap().to_string()))
            } else {
                Err(MissingHeader)
            }
        })
    }
}

// Handler using the custom extractor
async fn handler(custom_header: CustomHeader) -&gt; String {
    format!("Custom Header: {}", custom_header.0)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-user-authentication-extractor"><a class="header" href="#example-2-user-authentication-extractor">Example 2: User Authentication Extractor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S&gt; FromRequestParts&lt;S&gt; for User
where
    MemoryStore: FromRef&lt;S&gt;,
    S: Send + Sync,
{
    type Rejection = AuthRedirect;

    async fn from_request_parts(parts: &amp;mut Parts, state: &amp;S) -&gt; Result&lt;Self, Self::Rejection&gt; {
        let store = MemoryStore::from_ref(state);
        
        // Extract cookies from request
        let cookies = parts
            .extract::&lt;TypedHeader&lt;headers::Cookie&gt;&gt;()
            .await
            .map_err(|_| AuthRedirect)?;

        // Get session cookie
        let session_cookie = cookies.get(COOKIE_NAME).ok_or(AuthRedirect)?;

        // Load session from store
        let session = store
            .load_session(session_cookie.to_string())
            .await
            .unwrap()
            .ok_or(AuthRedirect)?;

        // Get user from session
        let user = session.get::&lt;User&gt;("user").ok_or(AuthRedirect)?;

        Ok(user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-multiple-extractors"><a class="header" href="#example-3-multiple-extractors">Example 3: Multiple Extractors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::State,
    http::{Method, Uri},
    Router,
};

async fn handler(
    method: Method,
    uri: Uri,
    State(state): State&lt;String&gt;,
    CustomHeader(header): CustomHeader,
) -&gt; String {
    format!("Method: {}, URI: {}, State: {}, Header: {}", 
            method, uri, state, header)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="comparison-middleware-vs-fromrequestparts"><a class="header" href="#comparison-middleware-vs-fromrequestparts">Comparison: Middleware vs. FromRequestParts</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Middleware</th><th>FromRequestParts</th></tr></thead><tbody>
<tr><td>Scope</td><td>Global (all requests)</td><td>Handler-specific</td></tr>
<tr><td>Use Case</td><td>Logging, security policies, global validation</td><td>Extracting specific request data</td></tr>
<tr><td>Execution</td><td>Before handler</td><td>Before handler</td></tr>
<tr><td>Response Modification</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use-fromrequestparts"><a class="header" href="#when-to-use-fromrequestparts">When to Use FromRequestParts</a></h2>
<p>Use <code>FromRequestParts</code> when:</p>
<ol>
<li>You only need access to request metadata (headers, URI, method)</li>
<li>The request body must remain untouched for other handlers or middleware</li>
<li>You want to implement lightweight custom extractors</li>
<li>You need handler-specific data extraction</li>
<li>You're implementing authentication or session management</li>
</ol>
<p>Use <code>FromRequest</code> instead when:</p>
<ol>
<li>You need to parse the request body</li>
<li>You're working with JSON payloads</li>
<li>You need access to the complete request</li>
</ol>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<ul>
<li>Session management</li>
<li>Authentication/Authorization</li>
<li>Header validation</li>
<li>Request metadata extraction</li>
<li>Cookie processing</li>
<li>URI parameter extraction</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>Keep extractors focused on a single responsibility</li>
<li>Handle rejections gracefully with meaningful error responses</li>
<li>Consider performance implications when cloning data</li>
<li>Use type-safe approaches when possible</li>
<li>Implement proper error handling and rejections</li>
<li>Document extractor behavior and requirements</li>
</ol>
<h1 id="appendix-a-advanced-examples"><a class="header" href="#appendix-a-advanced-examples">Appendix A: Advanced Examples</a></h1>
<h2 id="a1-rate-limiting-extractor"><a class="header" href="#a1-rate-limiting-extractor">A.1 Rate Limiting Extractor</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use std::time::{Duration, Instant};

struct RateLimit;

#[derive(Debug)]
struct RateLimitExceeded;

impl IntoResponse for RateLimitExceeded {
    fn into_response(self) -&gt; Response {
        (
            StatusCode::TOO_MANY_REQUESTS,
            "Rate limit exceeded. Please try again later.",
        )
            .into_response()
    }
}

#[derive(Clone)]
struct RateLimiter {
    requests: Arc&lt;Mutex&lt;HashMap&lt;String, Vec&lt;Instant&gt;&gt;&gt;&gt;,
    max_requests: usize,
    window: Duration,
}

impl&lt;S&gt; FromRequestParts&lt;S&gt; for RateLimit
where
    RateLimiter: FromRef&lt;S&gt;,
    S: Send + Sync,
{
    type Rejection = RateLimitExceeded;

    async fn from_request_parts(
        parts: &amp;mut Parts,
        state: &amp;S,
    ) -&gt; Result&lt;Self, Self::Rejection&gt; {
        let limiter = RateLimiter::from_ref(state);
        let ip = parts
            .headers
            .get("X-Forwarded-For")
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown")
            .to_string();

        let now = Instant::now();
        let mut requests = limiter.requests.lock().await;
        
        if let Some(times) = requests.get_mut(&amp;ip) {
            times.retain(|&amp;t| now - t &lt; limiter.window);
            if times.len() &gt;= limiter.max_requests {
                return Err(RateLimitExceeded);
            }
            times.push(now);
        } else {
            requests.insert(ip, vec![now]);
        }
        
        Ok(RateLimit)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a2-content-type-validator"><a class="header" href="#a2-content-type-validator">A.2 Content Type Validator</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JsonContentType;

#[derive(Debug)]
struct InvalidContentType;

impl IntoResponse for InvalidContentType {
    fn into_response(self) -&gt; Response {
        (
            StatusCode::UNSUPPORTED_MEDIA_TYPE,
            "Content-Type must be application/json",
        )
            .into_response()
    }
}

impl&lt;S&gt; FromRequestParts&lt;S&gt; for JsonContentType {
    type Rejection = InvalidContentType;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let content_type = parts
            .headers
            .get(CONTENT_TYPE)
            .and_then(|v| v.to_str().ok())
            .unwrap_or("");

        Box::pin(async move {
            if content_type.starts_with("application/json") {
                Ok(JsonContentType)
            } else {
                Err(InvalidContentType)
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="appendix-b-authentication-examples"><a class="header" href="#appendix-b-authentication-examples">Appendix B: Authentication Examples</a></h1>
<h2 id="b1-bearer-token-authentication"><a class="header" href="#b1-bearer-token-authentication">B.1 Bearer Token Authentication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BearerToken(String);

#[derive(Debug)]
enum AuthError {
    Missing,
    Invalid,
}

impl IntoResponse for AuthError {
    fn into_response(self) -&gt; Response {
        let (status, message) = match self {
            AuthError::Missing =&gt; (
                StatusCode::UNAUTHORIZED,
                "Authorization header missing",
            ),
            AuthError::Invalid =&gt; (
                StatusCode::UNAUTHORIZED,
                "Invalid bearer token",
            ),
        };
        
        (status, message).into_response()
    }
}

impl&lt;S&gt; FromRequestParts&lt;S&gt; for BearerToken {
    type Rejection = AuthError;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let auth_header = parts
            .headers
            .get(AUTHORIZATION)
            .and_then(|h| h.to_str().ok())
            .ok_or(AuthError::Missing)?;

        Box::pin(async move {
            if !auth_header.starts_with("Bearer ") {
                return Err(AuthError::Invalid);
            }
            
            let token = auth_header[7..].to_string();
            if token.is_empty() {
                return Err(AuthError::Invalid);
            }
            
            Ok(BearerToken(token))
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="b2-api-key-validation"><a class="header" href="#b2-api-key-validation">B.2 API Key Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ApiKey(String);

#[derive(Debug)]
enum ApiKeyError {
    Missing,
    Invalid,
}

impl&lt;S&gt; FromRequestParts&lt;S&gt; for ApiKey {
    type Rejection = ApiKeyError;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let headers = parts.headers.clone();
        
        Box::pin(async move {
            let api_key = headers
                .get("X-API-Key")
                .ok_or(ApiKeyError::Missing)?
                .to_str()
                .map_err(|_| ApiKeyError::Invalid)?;
            
            if api_key.len() &lt; 32 {
                return Err(ApiKeyError::Invalid);
            }
            
            Ok(ApiKey(api_key.to_string()))
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="appendix-c-utility-examples"><a class="header" href="#appendix-c-utility-examples">Appendix C: Utility Examples</a></h1>
<h2 id="c1-request-id-tracking"><a class="header" href="#c1-request-id-tracking">C.1 Request ID Tracking</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
struct RequestId(Arc&lt;str&gt;);

impl&lt;S&gt; FromRequestParts&lt;S&gt; for RequestId {
    type Rejection = std::convert::Infallible;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let request_id = parts
            .headers
            .get("X-Request-ID")
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string())
            .unwrap_or_else(|| Uuid::new_v4().to_string());

        Box::pin(async move {
            Ok(RequestId(Arc::from(request_id)))
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="c2-user-agent-parser"><a class="header" href="#c2-user-agent-parser">C.2 User Agent Parser</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserAgent(String);

impl&lt;S&gt; FromRequestParts&lt;S&gt; for UserAgent {
    type Rejection = std::convert::Infallible;

    fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Self, Self::Rejection&gt;&gt; {
        let user_agent = parts
            .headers
            .get(header::USER_AGENT)
            .and_then(|h| h.to_str().ok())
            .unwrap_or("unknown")
            .to_string();

        Box::pin(async move {
            Ok(UserAgent(user_agent))
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Note: All examples assume appropriate imports from <code>axum</code>, <code>tokio</code>, and other required crates. Error handling has been simplified for clarity in some cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-authentication-with-axum-session-handling-and-redirection"><a class="header" href="#user-authentication-with-axum-session-handling-and-redirection">User Authentication with Axum: Session Handling and Redirection</a></h1>
<p>This document explains the implementation of user authentication in an Axum-based web application using session cookies. The authentication flow involves extracting user data from session cookies, handling missing or invalid sessions, and redirecting users when necessary.</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="axum-framework"><a class="header" href="#axum-framework">Axum Framework</a></h3>
<p><a href="https://github.com/tokio-rs/axum">Axum</a> is a web framework built on top of <a href="https://tokio.rs/">Tokio</a> and <a href="https://hyper.rs/">Hyper</a>, designed for building fast, reliable, and scalable APIs. It provides tools to handle requests, responses, routing, and extracting data from requests.</p>
<h3 id="authredirect-struct"><a class="header" href="#authredirect-struct"><code>AuthRedirect</code> Struct</a></h3>
<p>The <code>AuthRedirect</code> struct is used as a custom rejection type to handle cases where user authentication is missing or invalid. In Axum, when a request cannot be processed (for example, due to a failed authentication), a rejection type is returned.</p>
<p>The <code>AuthRedirect</code> struct triggers a temporary redirect response to the root URL (<code>/</code>), guiding unauthenticated users back to a login or home page.</p>
<h3 id="intoresponse-implementation-for-authredirect"><a class="header" href="#intoresponse-implementation-for-authredirect"><code>IntoResponse</code> Implementation for <code>AuthRedirect</code></a></h3>
<p>The <code>IntoResponse</code> trait is implemented for the <code>AuthRedirect</code> struct. This allows <code>AuthRedirect</code> to be returned as a response, which in this case is a redirect to the root URL:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IntoResponse for AuthRedirect {
    fn into_response(self) -&gt; Response {
        println!("AuthRedirect called.");
        Redirect::temporary("/").into_response()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When the <code>AuthRedirect</code> rejection is triggered, the user is redirected to the root path <code>/</code> with a temporary redirect (HTTP 302).</p>
<h3 id="fromrequestparts-for-user"><a class="header" href="#fromrequestparts-for-user"><code>FromRequestParts</code> for <code>User</code></a></h3>
<p>The <code>FromRequestParts</code> trait is implemented for extracting a <code>User</code> from the request parts. This trait allows the application to pull specific data from the request, such as cookies or headers.</p>
<p>In this implementation, we use <code>FromRequestParts</code> to extract the user from the session cookie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S&gt; FromRequestParts&lt;S&gt; for User
where
    S: Send + Sync,
{
    type Rejection = AuthRedirect;

    async fn from_request_parts(parts: &amp;mut Parts, _state: &amp;S) -&gt; Result&lt;Self, Self::Rejection&gt; {
        let cookies = parts
            .extract::&lt;TypedHeader&lt;headers::Cookie&gt;&gt;()
            .await
            .map_err(|_| AuthRedirect)?;

        // Get session from cookie
        let session_cookie = cookies
            .get(SESSION_COOKIE_NAME.as_str())
            .ok_or(AuthRedirect)?;
        let store_guard = SESSION_STORE.lock().await;
        let session = store_guard
            .get_store()
            .get(session_cookie)
            .await
            .map_err(|_| AuthRedirect)?;

        // Get user data from session
        let stored_session = session.ok_or(AuthRedirect)?;
        Ok(stored_session.user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="workflow-of-fromrequestparts-for-user"><a class="header" href="#workflow-of-fromrequestparts-for-user">Workflow of <code>FromRequestParts</code> for <code>User</code></a></h3>
<ol>
<li>Extract cookies from the request using the <code>TypedHeader&lt;headers::Cookie&gt;</code> extractor.</li>
<li>Attempt to find the session cookie by the predefined <code>SESSION_COOKIE_NAME</code>.</li>
<li>Look up the session in the <code>SESSION_STORE</code>, which is a shared store of session data.</li>
<li>If the session is found, return the <code>user</code> associated with the session.</li>
<li>If any of these steps fail (cookie not found, session not valid, etc.), an <code>AuthRedirect</code> rejection is triggered, and the user is redirected.</li>
</ol>
<h3 id="optionalfromrequestparts-for-user"><a class="header" href="#optionalfromrequestparts-for-user"><code>OptionalFromRequestParts</code> for <code>User</code></a></h3>
<p>The <code>OptionalFromRequestParts</code> trait is also implemented for the <code>User</code> type. This version attempts to extract the user, but instead of rejecting the request, it returns an <code>Option&lt;User&gt;</code>, meaning the user may or may not be present in the request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S&gt; OptionalFromRequestParts&lt;S&gt; for User
where
    S: Send + Sync,
{
    type Rejection = Infallible;

    async fn from_request_parts(
        parts: &amp;mut Parts,
        _state: &amp;S,
    ) -&gt; Result&lt;Option&lt;Self&gt;, Self::Rejection&gt; {
        match &lt;User as FromRequestParts&lt;S&gt;&gt;::from_request_parts(parts, _state).await {
            Ok(res) =&gt; Ok(Some(res)),
            Err(AuthRedirect) =&gt; Ok(None),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="workflow-of-optionalfromrequestparts-for-user"><a class="header" href="#workflow-of-optionalfromrequestparts-for-user">Workflow of <code>OptionalFromRequestParts</code> for <code>User</code></a></h3>
<ol>
<li>This method calls <code>from_request_parts</code> (which extracts the user) but returns an <code>Option&lt;User&gt;</code> instead of failing outright.</li>
<li>If the user is found, it returns <code>Some(user)</code>.</li>
<li>If the <code>AuthRedirect</code> rejection occurs (indicating an unauthenticated user), it returns <code>None</code> without triggering an error.</li>
</ol>
<h3 id="how-it-works-together"><a class="header" href="#how-it-works-together">How It Works Together</a></h3>
<ul>
<li><strong>User Authentication</strong>: The system checks the request for a session cookie and retrieves the associated user if the session is valid.</li>
<li><strong>Session Handling</strong>: If a valid session is found, the corresponding user is returned. If the session is invalid or missing, the user is redirected to the root URL (<code>/</code>).</li>
<li><strong>Flexible User Handling</strong>: The <code>OptionalFromRequestParts</code> trait allows for handling requests where the user may or may not be authenticated, making the code flexible for different routes or middleware.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This implementation demonstrates how to handle user authentication with Axum using session cookies. The system ensures that users are redirected if they are not authenticated while providing a flexible approach for optional authentication in certain parts of the application.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://docs.rs/axum/">Axum Documentation</a></li>
<li><a href="https://tokio.rs/docs/">Tokio Documentation</a></li>
<li><a href="https://docs.rs/hyper/">Hyper Documentation</a></li>
</ul>
<pre><code></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
